// AngleScript
#include <angelscript.h>

// AngleScript addons
#include "Scripts/AngelScriptAddons/scriptstdstring/scriptstdstring.h"
#include "Scripts/AngelScriptAddons/scriptbuilder/scriptbuilder.h"

#include "Containers/String.h"
#include "Containers/StringConv.h"
#include "Logger/LoggerMacros.h"
#include "Scripts/ScriptEngine.h"

#include "Misc/CoreGlobals.h"
#include "System/BaseArchive.h"
#include "System/BaseFileSystem.h"

// STL
#if WITH_EDITOR
	#include <sstream>
#endif // WITH_EDITOR

/**
 * Message callback from AngleScript engine
 */
void CDECL ASMessageCallback( const asSMessageInfo* InMessage, void* InParam )
{
	check( InMessage );

	ELogType		logType = LT_Log;
	switch ( InMessage->type )
	{
	case asMSGTYPE_WARNING:
		logType = LT_Warning;
		break;

	case asMSGTYPE_ERROR:
		logType = LT_Error;
		break;
	}

	LE_LOG( logType, LC_Script, TEXT( "%s (%d, %d) : %s" ), ANSI_TO_TCHAR( InMessage->section ), InMessage->row, InMessage->col, ANSI_TO_TCHAR( InMessage->message ) );
}

/**
 * Constructor
 */
ScriptEngine::ScriptEngine() :
	asScriptEngine( nullptr )
{}

/**
 * Destructor
 */
ScriptEngine::~ScriptEngine()
{
	if ( !asScriptEngine )		return;
	asScriptEngine->ShutDownAndRelease();
}

/**
 * Initialize
 */
void ScriptEngine::Init()
{
	if ( asScriptEngine )		return;

	// Create script engine
	asScriptEngine = asCreateScriptEngine( ANGELSCRIPT_VERSION );
	check( asScriptEngine );

	// The script compiler will send any compiler messages to the callback
	asScriptEngine->SetMessageCallback( asFUNCTION( ASMessageCallback ), 0, asCALL_CDECL );

	// Register std strings in scripts
	RegisterStdString( asScriptEngine );
}

#if WITH_EDITOR
/**
 * Compile scripts and generate headers for C++
 */
void ScriptEngine::Make( const tchar* InCmdLine )
{
	CScriptBuilder		asScriptBuilder;
	CompileModule( &asScriptBuilder, TEXT( "Core" ), TEXT( "Script" ), TEXT( "Script" )  );
	GenerateHeadersForModule( asScriptEngine->GetModule( "Core" ), TEXT( "Develompent/Source/Engine/Core/Include" ) );
}

/**
 * Compile module script
 */
void ScriptEngine::CompileModule( class CScriptBuilder* InScriptBuilder, const tchar* InNameModule, const tchar* InPathToModuleDir, const tchar* InOutputPath )
{
	check( InScriptBuilder && InNameModule && InPathToModuleDir && InOutputPath );

	InScriptBuilder->StartNewModule( asScriptEngine, TCHAR_TO_ANSI( InNameModule ) );
	
	BaseArchive*		arTestScript = GFileSystem->CreateFileReader( TEXT( "Script/Test.as" ), AR_NoFail );
	uint32				arSize = arTestScript->GetSize() + 1;
	byte*				buffer = new byte[ arSize + 1 ];
	memset( buffer, '\0', arSize );

	arTestScript->Serialize( buffer, arSize );

	int32		result = InScriptBuilder->AddSectionFromMemory( "Test", ( achar* )buffer, arSize-1 );
	check( result >= 0 );

	result = InScriptBuilder->BuildModule();
	check( result >= 0 );

	delete[] buffer;
	delete arTestScript;
}

/**
 * Generate C++ headers for module
 */
void ScriptEngine::GenerateHeadersForModule( class asIScriptModule* InScriptModule, const tchar* InOutputPath )
{
	check( InScriptModule && InOutputPath );

	BaseArchive*			arCPPHeader = GFileSystem->CreateFileWriter( String::Format( TEXT( "%s/%sClasses.h" ), InOutputPath, ANSI_TO_TCHAR( InScriptModule->GetName() ) ), AW_NoFail );

	*arCPPHeader << "/*=========================================\n";
	*arCPPHeader << " C++ class definitions exported from AngelScript.\n";
	*arCPPHeader << " This is automatically generated by the tools.\n";
	*arCPPHeader << " DO NOT modify this manually! Edit the corresponding .as files instead!\n";
	*arCPPHeader << " BSOD-Games, All Rights Reserved.\n";
	*arCPPHeader << "==========================================*/\n\n";

	*arCPPHeader << "#include <angelscript.h>\n\n";

	uint32			coutFunctions = InScriptModule->GetFunctionCount();
	for ( uint32 indexFunction = 0; indexFunction < coutFunctions; ++indexFunction )
	{
		*arCPPHeader << ( achar* )GenerateCPPFunction( InScriptModule, indexFunction ).c_str() << "\n";

		if ( indexFunction + 1 < coutFunctions )
		{
			*arCPPHeader << "\n";
		}
	}

	delete arCPPHeader;
}

/**
 * Generate C++ code of function
 */
std::string ScriptEngine::GenerateCPPFunction( class asIScriptModule* InScriptModule, uint32 InIndexFunction )
{
	check( InScriptModule && InIndexFunction >= 0 && InIndexFunction < InScriptModule->GetFunctionCount() );

	asIScriptFunction*		function = InScriptModule->GetFunctionByIndex( InIndexFunction );
	check( function );

	// Get return type of function
	std::stringstream		strStream;	
	ECPPType				cppReturnType = CPPT_Unknown;
	{
		asDWORD		retTypeFlags = 0;
		int32		retTypeId = function->GetReturnTypeId( &retTypeFlags );

		cppReturnType = TypeID_To_ECPPType( retTypeId );
	}

	// Get all params in function
	std::vector< SCPPParam >		params;
	std::string						strParamsDeclaration;

	for ( uint32 indexParam = 0, countParams = function->GetParamCount(); indexParam < countParams; ++indexParam )
	{
		SCPPParam		cppParam = GetCPPParamFromFunction( function, indexParam );
		params.push_back( cppParam );

		// Generate declaration of params for header function
		strParamsDeclaration += cppParam.ToString();	
		if ( indexParam + 1 < countParams )
		{
			strParamsDeclaration += ", ";
		}	
	}

	// Generate header of function
	// Example: float execTest( float InA )
	strStream << ECPPType_To_String( cppReturnType ) << " exec" << function->GetName() << ( params.empty() ? "()" : ( "( " + strParamsDeclaration + " )" ) ) << "\n";
	strStream << "{\n";

	// Generate prepare to execute script function
	strStream << "\tasIScriptContext*		scriptContext = GScriptEngine->GetASScriptEngine()->CreateContext();\n";
	strStream << "\tcheck( scriptContext );\n\n";

	strStream << "\tasIScriptFunction*		function = GScriptEngine->GetASScriptEngine()->GetModule( \"" << function->GetModuleName() << "\" )->GetFunctionByIndex( " << InIndexFunction << " );\n";
	strStream << "\tcheck( function );\n\n";

	strStream << "\tint32	result = scriptContext->Prepare( function );\n";
	strStream << "\tcheck( result >= 0 );\n\n";

	// Generate code for set arguments for start function
	for ( uint32 indexParam = 0, countParams = ( uint32 )params.size(); indexParam < countParams; ++indexParam )
	{
		const SCPPParam&		cppParam = params[ indexParam ];
		std::string				callMethod;

		switch ( cppParam.type )
		{
			// Int8/UInt8 and Bool
		case CPPT_Int8:
		case CPPT_UInt8:
		case CPPT_Bool:
			callMethod = "SetArgByte( " + std::to_string( indexParam ) + ", " + cppParam.name + " )";
			break;

			// Int16 and UInt16
		case CPPT_Int16:
		case CPPT_UInt16:
			callMethod = "SetArgWord( " + std::to_string( indexParam ) + ", " + cppParam.name + " )";
			break;

			// Int32 and UInt32
		case CPPT_Int32:
		case CPPT_UInt32:
			callMethod = "SetArgDWord( " + std::to_string( indexParam ) + ", " + cppParam.name + " )";
			break;

			// Int64 and UInt64
		case CPPT_Int64:
		case CPPT_UInt64:
			callMethod = "SetArgQWord( " + std::to_string( indexParam ) + ", " + cppParam.name + " )";
			break;

			// Float
		case CPPT_Float:
			callMethod = "SetArgFloat( " + std::to_string( indexParam ) + ", " + cppParam.name + " )";
			break;

			// Double
		case CPPT_Double:
			callMethod = "SetArgDouble( " + std::to_string( indexParam ) + ", " + cppParam.name + " )";
			break;

		default:
			appErrorf( TEXT( "CPPType 0x%X in param %s not supported" ), cppParam.type, ANSI_TO_TCHAR( cppParam.name.c_str() ) );
			break;
		}

		strStream << "\tscriptContext->" << callMethod << ";\n";

		if ( indexParam + 1 == countParams )
		{
			strStream << "\n";
		}
	}

	// Execute script function
	strStream << "\tresult = scriptContext->Execute();\n";
	strStream << "\tcheck( result >= 0 );\n";

	// Return value from function after execute
	if ( cppReturnType != CPPT_Void )
	{
		strStream << "\n";
		strStream << "\t" << ECPPType_To_String( cppReturnType ) << "	returnValue = ";
	}

	switch ( cppReturnType )
	{
		// Nothing return
	case CPPT_Void:
		break;

		// Return bool or int8 or uint8
	case CPPT_Bool:
	case CPPT_Int8:
	case CPPT_UInt8:
		strStream << "scriptContext->GetReturnByte();\n";
		break;

		// Return int16 or uint16
	case CPPT_Int16:
	case CPPT_UInt16:
		strStream << "scriptContext->GetReturnWord();\n";
		break;

		// Return int32 or uint32
	case CPPT_Int32:
	case CPPT_UInt32:
		strStream << "scriptContext->GetReturnDWord();\n";
		break;

		// Return int64 or uint64
	case CPPT_Int64:
	case CPPT_UInt64:
		strStream << "scriptContext->GetReturnQWord();\n";
		break;

		// Return float
	case CPPT_Float:
		strStream << "scriptContext->GetReturnFloat();\n";
		break;

		// Return double
	case CPPT_Double:
		strStream << "scriptContext->GetReturnDouble();\n";
		break;

	default:
		appErrorf( TEXT( "Not supported CPP type 0x%X in function %s::%s" ), cppReturnType, ANSI_TO_TCHAR( function->GetModuleName() ), ANSI_TO_TCHAR( function->GetName() ) );
		break;
	}

	// End of function
	strStream << "\tscriptContext->Release();\n";
	
	if ( cppReturnType != CPPT_Void )
	{
		strStream << "\treturn returnValue;\n";
	}

	strStream << "}";

	return strStream.str();
}

/**
 * Get C++ param from function
 */
ScriptEngine::SCPPParam ScriptEngine::GetCPPParamFromFunction( class asIScriptFunction* InScriptFunction, uint32 InIndexParam ) const
{
	check( InScriptFunction && InIndexParam >= 0 && InIndexParam < InScriptFunction->GetParamCount() );

	int32			typeId = 0;
	asDWORD			flags = 0;
	const char*		name = "";
	const char*		defaultArg = "";

	int32			result = InScriptFunction->GetParam( InIndexParam, &typeId, &flags, &name, &defaultArg );
	check( result >= 0 );

	return SCPPParam{ name, TypeID_To_ECPPType( typeId ) };
}

/**
 * Convert AngleScript TypeID to ECPPType
 */
ScriptEngine::ECPPType ScriptEngine::TypeID_To_ECPPType( int32 InTypeID )
{
	asETypeIdFlags		asType = ( asETypeIdFlags ) InTypeID;

	// Void
	if ( asType == asTYPEID_VOID )
	{
		return CPPT_Void;
	}

	// Bool
	else if ( asType == asTYPEID_BOOL )
	{
		return CPPT_Bool;
	}

	// Int8
	else if ( asType == asTYPEID_INT8 )
	{
		return CPPT_Int8;
	}

	// Int16
	else if ( asType == asTYPEID_INT16 )
	{
		return CPPT_Int16;
	}

	// Int32
	else if ( asType == asTYPEID_INT32 )
	{
		return CPPT_Int32;
	}

	// Int64
	else if ( asType == asTYPEID_INT64 )
	{
		return CPPT_Int64;
	}

	// Uint8
	else if ( asType == asTYPEID_UINT8 )
	{
		return CPPT_UInt8;
	}

	// Uint16
	else if ( asType == asTYPEID_UINT16 )
	{
		return CPPT_UInt16;
	}

	// Uint32
	else if ( asType == asTYPEID_UINT32 )
	{
		return CPPT_UInt32;
	}

	// Uint64
	else if ( asType == asTYPEID_UINT64 )
	{
		return CPPT_UInt64;
	}

	// Float
	else if ( asType == asTYPEID_FLOAT )
	{
		return CPPT_Float;
	}

	// Double
	else if ( asType == asTYPEID_DOUBLE )
	{
		return CPPT_Double;
	}

	// Unknown type - critiacal error
	else
	{
		appErrorf( TEXT( "Unknown type 0x%X of AngelScript" ), asType );
	}

	return CPPT_Unknown;
}

/**
 * Convert ECPPType to string
 */
std::string ScriptEngine::ECPPType_To_String( ECPPType InCPPType )
{
	static const char* nameCPPType[] =
	{
		"Unknown",		// CPPT_Unknown
		"void",			// CPPT_Void
		"bool",			// CPPT_Bool
		"int8",			// CPPT_Int8
		"int16",		// CPPT_Int16
		"int32",		// CPPT_Int32
		"int64",		// CPPT_Int64
		"uint8",		// CPPT_UInt8
		"uint16",		// CPPT_UInt16
		"uint32",		// CPPT_UInt32
		"uint64",		// CPPT_UInt64
		"float",		// CPPT_Float
		"double"		// CPPT_Double
	};

	return nameCPPType[ ( uint32 )InCPPType ];
}
#endif // WITH_EDITOR